#!/usr/bin/env perl
#
# Execute a test on the configured architecture.
#
# Exits with 69 (EX_UNAVAILABLE) if the test should be skipped
# because of incompatible configuration.
#

use File::Path "make_path";
use File::Basename;
use FindBin;
use Carp;
use strict;
use warnings;

# Environment settings used below
my $mode        = $ENV{MODE};
my $arch        = $ENV{ARCH} or die "No architecture specified";
my $obj_base    = $ENV{OBJ_BASE};
my $kernel      = $ENV{"KERNEL_${arch}"} || $ENV{KERNEL} || 'fiasco';
my $kernel_args = $ENV{KERNEL_ARGS} || '';
my $sigma0      = $ENV{SIGMA0} || "sigma0";
my $l4linux     = $ENV{"L4LX_KERNEL_${arch}"} || $ENV{L4LX_KERNEL};
my $ramdisk     = $ENV{"LINUX_RAMDISK_${arch}"} || $ENV{LINUX_RAMDISK};
my $bootstrap   = $ENV{BOOTSTRAP} || 'bootstrap';
my @modulepaths = split(/[:\s]+/, $ENV{SEARCHPATH});
# need a split according to the rules of shell quoting
my @qemu_args   = split("\0", qx:perl -e 'foreach (\@ARGV) { print "\$_\\0";}' -- $ENV{QEMU_ARGS}:) if $ENV{QEMU_ARGS};
my $test_setup  = $ENV{TEST_SETUP};
my $test_target = $ENV{TEST_TARGET};
my $test_args   = $ENV{TEST_ARGS} || '';
my $ned_cfg     = $ENV{NED_CFG};
my $moe_args    = $ENV{MOE_ARGS};
my @more_mods   = split(' ', $ENV{REQUIRED_MODULES});
my $hwconfig_file = $ENV{TEST_HWCONFIG} || '';
my $test_run_tags = $ENV{TEST_RUN_TAGS} || '';
my $test_required_tags = $ENV{TEST_TAGS};
my $roottask    = $ENV{TEST_ROOT_TASK} || 'moe';
my $roottask_args = $ENV{TEST_ROOT_TASK_ARGS} || '';

my $tmpdir      = $ENV{TEST_TMPDIR};
make_path($tmpdir);
push(@modulepaths, $tmpdir);

# array_minus removes all entries from the first array which exist in
# the second array. If the result is empty then the first is a subset
# of the second.
sub array_minus
{
  my %e = map{ $_ => undef } @{$_[1]};
  return grep( ! exists( $e{$_} ), @{$_[0]} );
}

# array_intersect keeps only those entries from the first array which
# exist in the second array.
sub array_intersect {
  my %e = map { $_ => undef } @{$_[0]};
  return grep { exists( $e{$_} ) } @{$_[1]};
}

sub get_module
{
  my $cmdline = shift;
  (my $file, my $args) = split (' ', $cmdline, 2);

  $args = $args ? " $args" : "";

  my $fullpath;
  if (-e $file and ! -d $file)
    {
      $fullpath = $file;
    }
  else
    {
      # go through the search path
      foreach my $p (@modulepaths)
        {
          my $fp = "$p/$file";
          if (-e "$fp" and ! -d "$fp")
            {
              $fullpath = $fp;
              last;
            }
        }
    }
  $fullpath or confess "Cannot find module $file";

  # check for compressed files (e.g. for linux)
  open(my $fh, '<', $fullpath) or confess "Cannot open '$fullpath': $!\n";
  my $buf;
  read($fh, $buf, 2);
  close($fh);

  if (length($buf) >= 2 && unpack("n", $buf) == 0x1f8b)
    {
      my $of = "$tmpdir/".basename($file);
      print STDERR "'$fullpath' is a zipped file, uncompressing to '$of'\n";

      system("zcat $fullpath >$of");

      return "$of$args";
    }

  return "$fullpath$args";
}

sub qemu_get_module
{
  my $cmdline = shift;
  my $fp = get_module($cmdline);
  $fp =~ s/,/,,/g;
  return $fp;
}

sub exit_skip
{
  print shift;
  exit 69;
}

sub exit_error
{
  print shift;
  exit 1;
}

sub generate_gtest_shuffle_seed
{
  # gtest uses the current time for seed generation which is rather
  # deterministic on a new QEMU VM. Hence, the host provides the seed.
  # gtest limits itself to an integer seed in range [0, 99999].
  $ENV{TEST_GTEST_SHUFFLE_SEED} ||= int(rand(100_000));
}

sub check_add_gtest_shuffle()
{
  # Shuffling test will disrupt the expected output.
  if ($ENV{TEST_EXPECTED} and ($ENV{TEST_GTEST_SHUFFLE}))
    {
      print "Warning: Expected output configured. Ignoring gtest shuffle.\n";
    }
  elsif ($ENV{TEST_GTEST_SHUFFLE})
    {
      generate_gtest_shuffle_seed();
      $test_args.=
        " --gtest_shuffle --gtest_random_seed=$ENV{TEST_GTEST_SHUFFLE_SEED}";
    }
}

# Check that a kernel has mandatory features enabled.
# Go through the configuration and make sure the required config option
# is enabled. If the configuration file is not found, it just prints
# a warning and continues.
sub check_config
{
  my $binname = shift;
  my $copts = shift;
  return if (!$copts);

  my $binary = shift;
  my $cfgfile = shift;

  my $kpath = qx/dirname `perl -e 'print \$ARGV[0]' $binary`/;
  chomp($kpath);
  $cfgfile = "${kpath}/$cfgfile";

  if (-e $cfgfile)
    {
      foreach my $copt (split(' ', $copts))
        {
          my $o = qx:grep ^$copt $cfgfile:;
          exit_skip("$binname not configured for $copt.\n") if (!$o);
        }
    }
  else
    {
      print "WARNING: $binname config not found at $cfgfile\n";
    }
}

# Are the tags required by the current test?
if (defined($test_required_tags))
  {
    # Remove whitespaces in both variables
    $test_run_tags =~ s/\s+//g;
    $test_required_tags =~ s/\s+//g;

    # Convert both strings to arrays
    my @test_forbidden_tags = map { s/^!(.*)/$1/; $_ } grep { /^!/ } split(/,/, $test_required_tags);
    my @test_required_tags = grep { /^[^!]/} split(/,/, $test_required_tags);
    my @test_run_tags = split(/,/, $test_run_tags);

    # Remove empty elements (just in case)
    @test_required_tags = grep { $_ ne '' } @test_required_tags;
    @test_run_tags = grep { $_ ne '' } @test_run_tags;

    # Check missing tags
    my @tags_missing = array_minus(\@test_required_tags, \@test_run_tags);
    if (scalar(@tags_missing) > 0)
      {
        exit_skip "requires additional run tags: " . join(", ", @tags_missing);
      }

    # Check forbidden tags
    my @tags_forbidden = array_intersect(\@test_forbidden_tags, \@test_run_tags);
    if (scalar(@tags_forbidden) > 0)
      {
        exit_skip "not supported with run tags: " . join(", ", @tags_forbidden);
      }
  }

# Any L4Re kernel features as requirements?
check_config('L4Re kernel', $ENV{"KERNEL_CONF"}, $kernel, 'globalconfig.out');

# check add gtest_shuffle unless specific output is expected.
check_add_gtest_shuffle();

# Create the initial module list
my @module_list = ();
my $test_env_cfg;
my $test_env_cfg_name = "$tmpdir/test_env.lua";
my $convert = "$FindBin::Bin/key-value-convert.pl"; # hwconfig converter in same path

if ($ned_cfg and $roottask eq 'moe')
  {
    # Create an additional LUA config file where environment variables can
    # be exported to.
    my $mod_list = '"'.join('","', map { s/:rw$//; $_ } map { $_ } @more_mods).'"';
    my $test_prog = $test_target;
    $test_prog .= ' '.$test_args if $test_args;
    open($test_env_cfg, '>', $test_env_cfg_name)
      or confess "Cannot create configuration file $test_env_cfg_name.";

    print $test_env_cfg "local t = {}\n";
    print $test_env_cfg "t.TEST_PROG = '$test_prog'\n";
    print $test_env_cfg "t.REQUIRED_MODULES = {$mod_list}\n";
    if ($hwconfig_file)
      {
        die "Hardware config '$hwconfig_file' not found." if (! -e $hwconfig_file);
        # Provide hwconfig as hash
        print $test_env_cfg "t.HWCONFIG = {}\n";
        print $test_env_cfg qx($convert --to=lua --prefix='t.HWCONFIG.' '$hwconfig_file' | sort);
      }

    # Some more assembly required for L4Linux tests.
    if ($mode eq 'l4linux')
      {
        $test_env_cfg or confess "L4Linux tests needs to be run with moe config.";
        # Check that the right version is available.
        # This is optional, missing parts lead to a simple skip of the test.
        exit_skip("No L4Linux binary provided.") if (!$l4linux);
        exit_skip("No ramdisk for L4Linux provided.") if (!$ramdisk);
        check_config('L4Linux kernel', $ENV{"L4LINUX_CONF"}.' CONFIG_L4_CHR_DS_DRV',
          $l4linux, '.config');

        push (@module_list, $l4linux);
        push (@module_list, $ramdisk);

        my $l4linux_bin = basename($l4linux);
        my $ramdisk_bin = basename($ramdisk);
        my $ramdisk_size= qx(du -b $ramdisk);
        chomp($ramdisk_size);
        print $test_env_cfg "t.L4LX_EXEC_CMD = 'rom/$l4linux_bin l4x_rd=rom/$ramdisk_bin ramdisk_size=$ramdisk_size l4re_testprog=/dev/rom/$test_target l4cdds.add=rom/$test_target console=ttyLv0'\n";
      }
    print $test_env_cfg "return t\n";

    # Now set up boot for use with ned.
    (my $ned_cfg_name = $ned_cfg) =~ s/.*\///;
    $roottask .= " $moe_args rom/$ned_cfg_name";
    push(@module_list, "ned");
    push(@module_list, "test_env.lua");
    push(@module_list, $ned_cfg);
  }
elsif ($roottask eq 'moe')
  {
    # Run the test program directly as the init process.
    $roottask .= " --init=rom/$test_target $moe_args";
    $roottask .= " -- ".$test_args if $test_args;
  }
else
  {
    $roottask .= " -- ".$roottask_args if $roottask_args;
  }
push(@module_list, "l4re");
push(@module_list, map { s/:rw$/ :rw/; $_ } map { $_ } @more_mods);
push(@module_list, $test_target);

# If any binary was linked dynamically, we need to add the necessary .so files.
my @inmods = map { get_module($_) } @module_list;
my %shared_libs = ();
foreach my $mod (@inmods)
  {
    (my $executable) = split(' ', $mod, 2);
    my $libs = `objdump -p $executable 2>/dev/null | grep NEEDED`;
    foreach my $lib (split /\n/, $libs)
      {
        $lib =~ s/\s*NEEDED\s*//;
        $shared_libs{$lib} = 1 if $lib;
      }
  }

push(@module_list, keys %shared_libs);


my $test_modules;
my $test_modules_name = "$tmpdir/__test_modules.list";
open($test_modules, '>', $test_modules_name)
  or confess "Cannot create configuration file $test_modules_name.";

print $test_modules <<EOHEADER;

entry maketest
kernel $kernel $kernel_args
bootstrap $bootstrap
sigma0 $sigma0
roottask $roottask
EOHEADER

print $test_modules "module $_\n" foreach @module_list;

# run any potential pre-test setup scripts
if ($test_setup)
  {
    system($test_setup);
    if ($?)
      {
        exit $? >> 8;
      }
  }

my @runargs = qw(-serial stdio -nographic -monitor none);

close($test_env_cfg) if ($test_env_cfg);
my $module_search_path=join(":", @modulepaths);
my $qemu_options = join(' ', map { qq{"$_"} } (@qemu_args, @runargs));
chdir $obj_base;
$ENV{QEMU_OPTIONS} = $qemu_options;
$ENV{MODULES_LIST} = $test_modules_name;
$ENV{MODULE_SEARCH_PATH} = $module_search_path;

print "$_='$ENV{$_}' " foreach qw(QEMU_OPTIONS MODULES_LIST MODULE_SEARCH_PATH);

if ($ENV{IMAGE_TYPE})
  {
    my $cmd = "make $ENV{IMAGE_TYPE} E=maketest";
    print $cmd."\n";
    my $retval = system($cmd);
    if ($retval == 0)
      {
        exit_skip "Just creating boot image.\n";
      }
    else
      {
        exit_error "Error creating boot image.\n";
      }
  }

if (my $test_starter = $ENV{EXTERNAL_TEST_STARTER})
  {
    # MODULES_LIST is set
    my $piperead;
    if (!open ($piperead, '-|', $test_starter))
      {
        print "Error starting $test_starter: $!\n";
        exit 1;
      }
    STDOUT->autoflush(1);
    print $_ while <$piperead>;
    close $piperead;
    exit 0;
  }


my @cmd = (qw(make qemu E=maketest));
print join(' ', @cmd)."\n";
exec @cmd;
